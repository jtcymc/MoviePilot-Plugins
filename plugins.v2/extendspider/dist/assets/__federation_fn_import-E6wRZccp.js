const L="[0-9A-Za-z-]+",P=`(?:\\+(${L}(?:\\.${L})*))`,R="0|[1-9]\\d*",_="[0-9]+",Z="\\d*[a-zA-Z-][a-zA-Z0-9-]*",S=`(?:${_}|${Z})`,N=`(?:-?(${S}(?:\\.${S})*))`,X=`(?:${R}|${Z})`,k=`(?:-(${X}(?:\\.${X})*))`,w=`${R}|x|X|\\*`,d=`[v=\\s]*(${w})(?:\\.(${w})(?:\\.(${w})(?:${k})?${P}?)?)?`,D=`^\\s*(${d})\\s+-\\s+(${d})\\s*$`,J=`(${_})\\.(${_})\\.(${_})`,Q=`[v=\\s]*${J}${N}?${P}?`,y="((?:<|>)?=?)",U=`(\\s*)${y}\\s*(${Q}|${d})`,F="(?:~>?)",W=`(\\s*)${F}\\s+`,K="(?:\\^)",Y=`(\\s*)${K}\\s+`,A="(<|>)?=?\\s*\\*",j=`^${K}${d}$`,m=`(${R})\\.(${R})\\.(${R})`,ee=`v?${m}${k}?${P}?`,re=`^${F}${d}$`,ne=`^${y}\\s*${d}$`,se=`^${y}\\s*(${ee})$|^$`,te="^\\s*>=\\s*0.0.0\\s*$";function o(e){return new RegExp(e)}function c(e){return!e||e.toLowerCase()==="x"||e==="*"}function B(...e){return s=>e.reduce((t,r)=>r(t),s)}function E(e){return e.match(o(se))}function z(e,s,t,r){const n=`${e}.${s}.${t}`;return r?`${n}-${r}`:n}function ie(e){return e.replace(o(D),(s,t,r,n,i,$,u,f,a,l,V,p)=>(c(r)?t="":c(n)?t=`>=${r}.0.0`:c(i)?t=`>=${r}.${n}.0`:t=`>=${t}`,c(a)?f="":c(l)?f=`<${+a+1}.0.0-0`:c(V)?f=`<${a}.${+l+1}.0-0`:p?f=`<=${a}.${l}.${V}-${p}`:f=`<=${f}`,`${t} ${f}`.trim()))}function $e(e){return e.replace(o(U),"$1$2$3")}function ue(e){return e.replace(o(W),"$1~")}function ce(e){return e.replace(o(Y),"$1^")}function fe(e){return e.trim().split(/\s+/).map(s=>s.replace(o(j),(t,r,n,i,$)=>c(r)?"":c(n)?`>=${r}.0.0 <${+r+1}.0.0-0`:c(i)?r==="0"?`>=${r}.${n}.0 <${r}.${+n+1}.0-0`:`>=${r}.${n}.0 <${+r+1}.0.0-0`:$?r==="0"?n==="0"?`>=${r}.${n}.${i}-${$} <${r}.${n}.${+i+1}-0`:`>=${r}.${n}.${i}-${$} <${r}.${+n+1}.0-0`:`>=${r}.${n}.${i}-${$} <${+r+1}.0.0-0`:r==="0"?n==="0"?`>=${r}.${n}.${i} <${r}.${n}.${+i+1}-0`:`>=${r}.${n}.${i} <${r}.${+n+1}.0-0`:`>=${r}.${n}.${i} <${+r+1}.0.0-0`)).join(" ")}function ae(e){return e.trim().split(/\s+/).map(s=>s.replace(o(re),(t,r,n,i,$)=>c(r)?"":c(n)?`>=${r}.0.0 <${+r+1}.0.0-0`:c(i)?`>=${r}.${n}.0 <${r}.${+n+1}.0-0`:$?`>=${r}.${n}.${i}-${$} <${r}.${+n+1}.0-0`:`>=${r}.${n}.${i} <${r}.${+n+1}.0-0`)).join(" ")}function le(e){return e.split(/\s+/).map(s=>s.trim().replace(o(ne),(t,r,n,i,$,u)=>{const f=c(n),a=f||c(i),l=a||c($);return r==="="&&l&&(r=""),u="",f?r===">"||r==="<"?"<0.0.0-0":"*":r&&l?(a&&(i=0),$=0,r===">"?(r=">=",a?(n=+n+1,i=0,$=0):(i=+i+1,$=0)):r==="<="&&(r="<",a?n=+n+1:i=+i+1),r==="<"&&(u="-0"),`${r+n}.${i}.${$}${u}`):a?`>=${n}.0.0${u} <${+n+1}.0.0-0`:l?`>=${n}.${i}.0${u} <${n}.${+i+1}.0-0`:t})).join(" ")}function oe(e){return e.trim().replace(o(A),"")}function pe(e){return e.trim().replace(o(te),"")}function b(e,s){return e=+e||e,s=+s||s,e>s?1:e===s?0:-1}function de(e,s){const{preRelease:t}=e,{preRelease:r}=s;if(t===void 0&&r)return 1;if(t&&r===void 0)return-1;if(t===void 0&&r===void 0)return 0;for(let n=0,i=t.length;n<=i;n++){const $=t[n],u=r[n];if($!==u)return $===void 0&&u===void 0?0:$?u?b($,u):-1:1}return 0}function v(e,s){return b(e.major,s.major)||b(e.minor,s.minor)||b(e.patch,s.patch)||de(e,s)}function x(e,s){return e.version===s.version}function Re(e,s){switch(e.operator){case"":case"=":return x(e,s);case">":return v(e,s)<0;case">=":return x(e,s)||v(e,s)<0;case"<":return v(e,s)>0;case"<=":return x(e,s)||v(e,s)>0;case void 0:return!0;default:return!1}}function Ve(e){return B(fe,ae,le,oe)(e)}function ve(e){return B(ie,$e,ue,ce)(e.trim()).split(/\s+/).join(" ")}function _e(e,s){if(!e)return!1;const n=ve(s).split(" ").map(p=>Ve(p)).join(" ").split(/\s+/).map(p=>pe(p)),i=E(e);if(!i)return!1;const[,$,,u,f,a,l]=i,V={version:z(u,f,a,l),major:u,minor:f,patch:a,preRelease:l?.split(".")};for(const p of n){const g=E(p);if(!g)return!1;const[,H,,O,q,I,h]=g,M={operator:H,version:z(O,q,I,h),major:O,minor:q,patch:I,preRelease:h?.split(".")};if(!Re(M,V))return!1}return!0}const C={},T=Object.create(null);async function he(e,s="default"){return T[e]?new Promise(t=>t(T[e])):await be(e,s)||Te(e)}async function be(e,s){let t=null;if(globalThis?.__federation_shared__?.[s]?.[e]){const r=globalThis.__federation_shared__[s][e],n=C[e]?.requiredVersion;if(!!n){const $=Object.keys(r).find(u=>_e(u,n));$?t=await(await r[$].get())():console.log(`provider support ${e}(${$}) is not satisfied requiredVersion(\${moduleMap[name].requiredVersion})`)}else{const $=Object.keys(r)[0];t=await(await r[$].get())()}}if(t)return G(t,e)}async function Te(e){if(C[e]?.import){let s=await(await C[e].get())();return G(s,e)}else console.error("consumer config import=false,so cant use callback shared module")}function G(e,s){return typeof e.default=="function"?(Object.keys(e).forEach(t=>{t!=="default"&&(e.default[t]=e[t])}),T[s]=e.default,e.default):(e.default&&(e=Object.assign({},e.default,e)),T[s]=e,e)}export{he as importShared,Te as importSharedLocal,be as importSharedRuntime};
